{"version":3,"sources":["../src/selection.js"],"names":["splitedTable","editor","table","startKey","tableDepth","length","cells","nodes","Editor","at","match","n","type","node","cell","path","push","realPath","gridTable","insertPosition","i","rowspan","colspan","y","x","j","k","_y","_x","slice","isReal","originPath","key","isInsertPosition","getCol","result","forEach","row","col","removeSelection","Transforms","unsetNodes","selectedCell","addSelection","startPath","endPath","Path","equals","head","tail","tailPath","headPath","item","index","Math","min","max","coverCols","isOver","findIndex","setNodes"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n/* eslint-disable no-restricted-syntax */\nimport { Transforms, Editor, Path } from 'slate';\n\nexport const splitedTable = (editor, table, startKey) => {\n  const tableDepth = table[1].length;\n\n  const cells = [];\n\n  const nodes = Editor.nodes(editor, {\n    at: table[1],\n    match: n => n.type === 'table_cell',\n  });\n\n  for (const node of nodes) {\n    const [cell, path] = node;\n    cells.push({\n      cell,\n      path,\n      realPath: [...path],\n    });\n  }\n\n  const gridTable = [];\n  let insertPosition = null;\n\n  for (let i = 0; i < cells.length; i++) {\n    const { cell, path, realPath } = cells[i];\n    const { rowspan = 1, colspan = 1 } = cell;\n    const y = path[tableDepth];\n    let x = path[tableDepth + 1];\n\n    if (!gridTable[y]) {\n      gridTable[y] = [];\n    }\n\n    while (gridTable[y][x]) {\n      x++;\n    }\n\n    for (let j = 0; j < rowspan; j++) {\n      for (let k = 0; k < colspan; k++) {\n        const _y = y + j;\n        const _x = x + k;\n\n        if (!gridTable[_y]) {\n          gridTable[_y] = [];\n        }\n\n        gridTable[_y][_x] = {\n          cell,\n          path: [...realPath.slice(0, tableDepth), _y, _x],\n          isReal: (rowspan === 1 && colspan === 1) || (_y === y && _x === x),\n          originPath: path,\n        };\n\n        if (!insertPosition && cell.key === startKey) {\n          insertPosition = gridTable[_y][_x];\n          gridTable[_y][_x].isInsertPosition = true;\n        }\n      }\n    }\n  }\n\n  const getCol = (match) => {\n    const result = [];\n\n    gridTable.forEach(row => {\n      row.forEach((col) => {\n        if (match && match(col)) {\n          result.push(col);\n        }\n      });\n    });\n\n    return result;\n  };\n\n  return {\n    gridTable,\n    tableDepth,\n    getCol,\n  };\n};\n\nexport function removeSelection(editor) {\n  Transforms.unsetNodes(editor, 'selectedCell', {\n    at: [],\n    match: n => !!n.selectedCell,\n  });\n}\n\nexport function addSelection(\n  editor,\n  table,\n  startPath,\n  endPath,\n) {\n  removeSelection(editor);\n  // addSelectionStyle();\n\n  if (!table) return [];\n\n  const { gridTable, getCol } = splitedTable(editor, table);\n\n  if (!getCol || !gridTable) return [];\n\n  const [head] = getCol(\n    (n) =>\n      Path.equals(Editor.path(editor, n.originPath), startPath) && n.isReal,\n  );\n  const [tail] = getCol(\n    (n) =>\n      Path.equals(Editor.path(editor, n.originPath), endPath) && n.isReal,\n  );\n\n  if (!tail || !head) return [];\n\n  const { path: tailPath } = tail;\n  const { path: headPath } = head;\n\n  headPath.forEach((item, index) => {\n    headPath[index] = Math.min(item, tailPath[index]);\n    tailPath[index] = Math.max(item, tailPath[index]);\n  });\n\n  const coverCols = [];\n\n  gridTable.forEach((row) => {\n    row.forEach((col) => {\n      const { path } = col;\n\n      const isOver = path.findIndex((item, index) => {\n        if (item < headPath[index] || item > tailPath[index]) {\n          return true;\n        }\n        return false;\n      });\n\n      if (isOver < 0) {\n        coverCols.push(col);\n      }\n    });\n  });\n\n  coverCols.forEach(({ originPath }) => {\n    Transforms.setNodes(\n      editor,\n      {\n        selectedCell: true,\n      },\n      {\n        at: originPath,\n        match: n => n.type === 'table_cell',\n      },\n    );\n  });\n\n  return coverCols;\n}\n\n// export function removeSelectionStyle() {\n//   const style = document.querySelector(`style#${insertStyleId}`);\n//   if (style) {\n//     const head = document.getElementsByTagName('head');\n//     const first = head && head.item(0);\n//     first && first.removeChild(style);\n//   }\n// }\n\n// export function addSelectionStyle() {\n//   // HACK: Add ::selection style when greater than 1 cells selected.\n//   if (!document.querySelector(`style#${insertStyleId}`)) {\n//     const style = document.createElement('style');\n//     style.type = 'text/css';\n//     style.id = insertStyleId;\n//     const head = document.getElementsByTagName('head');\n//     const first = head && head.item(0);\n\n//     if (first) {\n//       first.appendChild(style);\n//       const stylesheet = style.sheet;\n\n//       if (stylesheet) {\n//         (stylesheet as CSSStyleSheet).insertRule(\n//           `table *::selection { background: none; }`,\n//           (stylesheet as CSSStyleSheet).cssRules.length\n//         );\n//       }\n//     }\n//   }\n// }\n"],"file":"selection.js"}