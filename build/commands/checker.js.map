{"version":3,"sources":["../../src/commands/checker.js"],"names":["checker","table","editor","direction","selection","Editor","edges","start","nodes","match","n","type","at","startNode","key","gridTable","selectedTable","startNodeColspan","colspan","startNodeRowspan","rowspan","hasMergedCells","selectedTableLen","length","nextNodeColspan","cell","undefined","nextNodeRowspan","error","console"],"mappings":";;;;;;;AAEA;;AACA;;AACA;;;;;;;;;;;;;;AAEA,IAAMA,OAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAQC,MAAR,EAAgBC,SAAhB,EAA8B;AAC1C,MAAI,CAACF,KAAD,IAAU,CAACC,MAAM,CAACE,SAAtB,EAAiC;;AACjC,MAAI;AAAA,wBACgBC,cAAOC,KAAP,CAAaJ,MAAb,EAAqBA,MAAM,CAACE,SAA5B,CADhB;AAAA;AAAA,QACOG,KADP;;AAAA,wBAEoBF,cAAOG,KAAP,CAAaN,MAAb,EAAqB;AACzCO,MAAAA,KAAK,EAAE,eAAAC,CAAC;AAAA,eAAIA,CAAC,CAACC,IAAF,KAAW,YAAf;AAAA,OADiC;AAEzCC,MAAAA,EAAE,EAAEL;AAFqC,KAArB,CAFpB;AAAA;AAAA,QAEOM,SAFP;;AAAA,QAMQC,GANR,GAMgBD,SAAS,CAAC,CAAD,CANzB,CAMQC,GANR;;AAAA,wBAOsB,6BAAaZ,MAAb,EAAqBD,KAArB,EAA4Ba,GAA5B,CAPtB;AAAA,QAOQC,SAPR,iBAOQA,SAPR;;AAQA,QAAMC,aAAa,GAAG,gCAAWD,SAAX,EAAsBF,SAAtB,EAAiCV,SAAjC,CAAtB;AACA,QAAMc,gBAAgB,GAAGJ,SAAS,CAAC,CAAD,CAAT,CAAaK,OAAb,IAAwB,CAAjD;AACA,QAAMC,gBAAgB,GAAGN,SAAS,CAAC,CAAD,CAAT,CAAaO,OAAb,IAAwB,CAAjD;AACA,QAAMC,cAAc,GAAGJ,gBAAgB,GAAG,CAAnB,IAAwBE,gBAAgB,GAAG,CAAlE;;AACA,QAAIhB,SAAS,KAAK,MAAlB,EAA0B;AACtB,UAAMmB,gBAAgB,GAAGN,aAAa,CAACO,MAAvC;AACA,UAAID,gBAAgB,GAAG,CAAnB,IAAwBH,gBAAgB,KAAKG,gBAAjD,EAAoE,OAAO,KAAP;AACpE,UAAME,eAAe,GAAGR,aAAa,CAACM,gBAAgB,GAAG,CAApB,CAAb,CAAoC,CAApC,EAAuCG,IAAvC,CAA4CP,OAA5C,IAAuDQ,SAA/E;AACA,UAAIT,gBAAgB,KAAK,CAArB,IAA0BO,eAAe,KAAKE,SAAlD,EAA6D,OAAO,IAAP;AAC7D,UAAIT,gBAAgB,KAAKO,eAAzB,EAA0C,OAAO,KAAP;AAC1C,aAAO,IAAP;AACH;;AACD,QAAIrB,SAAS,KAAK,OAAlB,EAA2B;AACvB,UAAMmB,iBAAgB,GAAGN,aAAa,CAAC,CAAD,CAAb,CAAiBO,MAA1C;AACA,UAAID,iBAAgB,GAAG,CAAnB,IAAwBL,gBAAgB,KAAKK,iBAAjD,EAAoE,OAAO,KAAP;AACpE,UAAMK,eAAe,GAAGX,aAAa,CAAC,CAAD,CAAb,CAAiBM,iBAAgB,GAAG,CAApC,EAAuCG,IAAvC,CAA4CL,OAA5C,IAAuDM,SAA/E;AACA,UAAIP,gBAAgB,KAAK,CAArB,IAA0BQ,eAAe,KAAKD,SAAlD,EAA6D,OAAO,IAAP;AAC7D,UAAIP,gBAAgB,KAAKQ,eAAzB,EAA0C,OAAO,KAAP;AAC1C,aAAO,IAAP;AACH;;AACD,QAAI,CAACxB,SAAD,IAAckB,cAAlB,EAAkC;AAC9B,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH,GAhCD,CAgCE,OAAOO,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACA,WAAO,KAAP;AACH;AAEJ,CAvCD;;eAyCe5B,O","sourcesContent":["/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable consistent-return */\r\nimport { Editor } from 'slate';\r\nimport { checkMerge } from './mergeSelection';\r\nimport { splitedTable } from '../selection';\r\n\r\nconst checker = (table, editor, direction) => {\r\n    if (!table || !editor.selection) return;\r\n    try {\r\n        const [start] = Editor.edges(editor, editor.selection);\r\n        const [startNode] = Editor.nodes(editor, {\r\n        match: n => n.type === 'table_cell',\r\n        at: start,\r\n        });\r\n        const { key } = startNode[0];\r\n        const { gridTable } = splitedTable(editor, table, key);\r\n        const selectedTable = checkMerge(gridTable, startNode, direction);\r\n        const startNodeColspan = startNode[0].colspan || 1;\r\n        const startNodeRowspan = startNode[0].rowspan || 1;\r\n        const hasMergedCells = startNodeColspan > 1 || startNodeRowspan > 1;\r\n        if (direction === 'down') {\r\n            const selectedTableLen = selectedTable.length;\r\n            if (selectedTableLen < 2 || startNodeRowspan === selectedTableLen ) return false;\r\n            const nextNodeColspan = selectedTable[selectedTableLen - 1][0].cell.colspan || undefined;\r\n            if (startNodeColspan === 1 && nextNodeColspan === undefined) return true;\r\n            if (startNodeColspan !== nextNodeColspan) return false;\r\n            return true;\r\n        }\r\n        if (direction === 'right') {\r\n            const selectedTableLen = selectedTable[0].length;\r\n            if (selectedTableLen < 2 || startNodeColspan === selectedTableLen ) return false;\r\n            const nextNodeRowspan = selectedTable[0][selectedTableLen - 1].cell.rowspan || undefined;\r\n            if (startNodeRowspan === 1 && nextNodeRowspan === undefined) return true;\r\n            if (startNodeRowspan !== nextNodeRowspan) return false;\r\n            return true;\r\n        }\r\n        if (!direction && hasMergedCells) {\r\n            return true;\r\n        }\r\n        return false;\r\n    } catch (error) {\r\n        console.error(error);\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\nexport default checker;"],"file":"checker.js"}